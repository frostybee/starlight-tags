---
title: Virtual Tags Module
description: Efficient, memoized access to tag data via the virtual module API
---

The `starlight-tags` plugin exposes a virtual module that gives you programmatic access to all processed tag data. This allows you to build custom components, create dynamic tag-based features, or integrate tags into your application logic.

## What is a Virtual Module?

A [virtual module](https://vite.dev/guide/api-plugin#virtual-modules-convention) is a Vite/Astro concept that provides access to data and functionality without an actual file on disk. The plugin creates `virtual:starlight-tagging/tags` at build time, making all your processed tag data available to any component or page.

## When to Use This

Use the virtual module when you need to:

- **Build custom components** that display tags differently than the built-in components
- **Create dynamic features** like tag clouds, filters, or search functionality
- **Access tag metadata** (counts, descriptions, prerequisites) programmatically
- **Integrate tags** with other parts of your application

If you just want to display tags on pages, the [built-in components](/starlight-tags/components/) are simpler and require no configuration.

## How It Works

When your site builds, the plugin reads your `tags.yml` configuration, processes all tag relationships, and counts how many pages use each tag. This processed data is then **cached in memory**.

The virtual module gives you access to this cache. You call `initTags()` once to load the data, then use the helper functions to query it. Don't worry about calling `initTags()` multiple times across different components as it's memoized, so the actual processing only happens once.

## Basic Usage

```astro
---
import { initTags, getTag, getAllTagsSorted } from 'virtual:starlight-tagging/tags';

// Initialize once (memoized - safe to call from any component)
await initTags();

// Use helper functions synchronously
const tag = getTag('authentication');
const allTags = getAllTagsSorted();
---
```

## Available Functions

### `initTags(options?)`

Initialize the tags store. Must be called before using other functions.

```ts
await initTags();

// With verbose logging (useful for debugging)
await initTags({ verbose: true });
```

This function is **memoized** - calling it multiple times only initializes once.

### `getTag(tagId)`

Get a specific tag by its ID.

```ts
const tag = getTag('authentication');
// Returns ProcessedTag | undefined
```

### `getTags()`

Get all tags as a Map.

```ts
const tagsMap = getTags();
// Returns Map<string, ProcessedTag>
```

### `getAllTagsSorted()`

Get all tags sorted by count (descending) then label (ascending).

```ts
const tags = getAllTagsSorted();
// Returns ProcessedTag[]
```

### `getTagsForPage(pageSlug)`

Get tags for a specific page by its slug.

```ts
const pageTags = getTagsForPage('guides/authentication');
// Returns ProcessedTag[]
```

### `getTagsByDifficulty(difficulty)`

Get tags filtered by difficulty level.

```ts
const beginnerTags = getTagsByDifficulty('beginner');
// Returns ProcessedTag[]
```

### `getTagsByContentType(contentType)`

Get tags filtered by content type. Available types: `lecture`, `lab`, `assignment`, `project`, `reference`, `tutorial`, `assessment`.

```ts
const tutorials = getTagsByContentType('tutorial');
const labs = getTagsByContentType('lab');
// Returns ProcessedTag[]
```

### `getLearningPath(startTagId, endTagId?)`

Get learning path between two tags.

```ts
const path = getLearningPath('basics', 'advanced');
// Returns string[] (tag IDs)
```

### `validatePrerequisites()`

Validate that all prerequisite references in your tags are valid (i.e., point to existing tags).

```ts
const result = validatePrerequisites();
// Returns { isValid: boolean; errors: string[] }

if (!result.isValid) {
  console.error('Invalid prerequisites:', result.errors);
}
```

### `isInitialized()`

Check if the tags store has been initialized.

```ts
if (isInitialized()) {
  // Safe to use sync functions
}
```

### `resetTagsStore()`

Reset the tags store. Primarily useful for testing or HMR (Hot Module Replacement) scenarios.

```ts
resetTagsStore();
// Store is now uninitialized - must call initTags() again
```

## Complete Example

```astro
---
import { TagsList } from 'starlight-tags/components';
import { initTags, getAllTagsSorted } from 'virtual:starlight-tagging/tags';

// Initialize tags store (memoized - safe to call multiple times)
await initTags();

// Get top 10 tags by popularity
const allTags = getAllTagsSorted();
const topTags = allTags.slice(0, 10);
---

<section>
  <h2>Popular Topics</h2>
  <TagsList
    tags={topTags}
    layout="grid"
    showCount={true}
    variant="outline"
  />
</section>
```

## Config Virtual Module

A second virtual module provides access to the plugin configuration:

```ts
import { config } from 'virtual:starlight-tagging/config';

// config contains:
// - configPath: string
// - tagsPagesPrefix: string
// - tagsIndexSlug: string
// - onInlineTagsNotFound: 'ignore' | 'warn' | 'error'
// - itemsPerPage: number
// - basePath: string
```

This is useful when building custom components that need to know the plugin's configuration, such as constructing tag URLs or understanding pagination settings.

## Advanced: Direct TagsProcessor Access

For advanced use cases where you need direct access to the `TagsProcessor` class (e.g., custom processing logic), you can import it directly:

```ts
import { TagsProcessor } from 'starlight-tags';
```

However, for most use cases, the virtual module API is recommended.
